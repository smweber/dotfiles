"$schema" = "https://jj-vcs.github.io/jj/latest/config-schema.json"

[user]
name = "Scott Weber"
email = "scott@r45.ca"

[aliases]
fetch   = ["git", "fetch", "--all-remotes"]
push    = ["git", "push"]
publish = ["git", "push", "--allow-new"]
clean   = ["util", "exec", "--", "git", "clean", "-e", ".jj", "-nx", ":/"]

#track = ["util", "exec", "--", "bash", "-ec", "jj bookmark track $1@origin && jj new $1", ""]

tug     = ["util", "exec", "--", "sh", "-c", """
if [ "x$1" = "x" ]; then
  jj bookmark move --from "closest_bookmark(@)" --to "closest_pushable(@)"
else
  jj bookmark move --to "closest_pushable(@)" "$@"
fi
""", ""]

# Adapted from https://github.com/glehmann/dotfiles/blob/main/.config/jj/config.toml
generate-bookmark-name = ["util", "exec", "--", "bash", "-ec", """
rev="closest_pushable(@)"
if [ -n "$1" ]; then
  rev=$1
fi
cat <<EOF > /tmp/jj-bookmark-prompt
Generate a short branch name for these commits.
Keep it short. It doesn't have to describe everything.
Only produce one branch name without explanation.
Use - as separator.
Don't include any / character in the branch name.
Never include WIP or feat in the branch name.

EOF
jj log -r "closest_bookmark($rev-)..$rev" --no-graph -T description -s >> /tmp/jj-bookmark-prompt
prefix=scott/
bookmark=$prefix`cat /tmp/jj-bookmark-prompt | llm --model gpt-5-nano`
change_id=`jj log -T 'change_id.short(4)' --no-graph -r $rev`
echo $bookmark-$change_id
""", ""]

# create and push bookmark
publish-auto = ["util", "exec", "--", "bash", "-ec", """
rev="closest_pushable(@)"
if [ -n "$1" ]; then
  rev=$1
fi
bookmark=`jj generate-bookmark-name $rev`
jj bookmark set -r $rev $bookmark
jj push -b $bookmark --allow-new
""", ""]

generate-commit-message = ["util", "exec", "--", "bash", "-ec", """
rev="@"
if [ -n "$1" ]; then
  rev=$1
fi
cat <<EOF > /tmp/jj-commit-message-prompt
Generate a short commit message based on this diff.
Keep it under 75 characters.
Only produce one line without explanation.
Do not include a period at the end.
Use only plain english, no prefixes like WIP or feat.

EOF
jj show --git $rev >> /tmp/jj-commit-message-prompt
commit_message=`cat /tmp/jj-commit-message-prompt | llm --model gpt-5-nano`
echo $commit_message
""", ""]

describe-auto = ["util", "exec", "--", "bash", "-ec", """
rev="@"
if [ -n "$1" ]; then
  rev=$1
fi
commit_message=`jj generate-commit-message $rev`
jj describe -m "$commit_message" $rev
""", ""]

commit-auto = ["util", "exec", "--", "bash", "-ec", """
rev="@"
if [ -n "$1" ]; then
  rev=$1
fi
commit_message=`jj generate-commit-message $rev`
jj commit -m "$commit_message"
""", ""]

# (From https://github.com/jj-vcs/jj/discussions/5812#discussioncomment-13095720)

# Some things to watch out for with jj aliases:
# - Keep them minimal; remain familiar with the builtin commands and defaults.
# - If they use -r, a command line -r will add to that, not override it.
# - If they use other options like -T or -n, those can't be overridden on the command line.

# log aliases. Most of these use -T and -n; the b and custom variants also use -r.
# All of them show graph structure; to hide it add --no-graph (can show confused output).

# "l" aliases: list recent changes on multiple branches, elided, as one line.
# add more l's to show more changes: l=10, ll=30, lll=100, llll=all
l           = ["log", "-Tlog1", "-n25"]
ll          = ["log", "-Tlog1"]

# append a for "all()", as log defaults to local commits only
la          = ["log", "-Tlog1", "-r", "all()", "-n25"]
lla         = ["log", "-Tlog1", "-r", "all()"]

# append v to show full descriptions
lv          = ["log", "-Tlogv", "-n25"]
llv         = ["log", "-Tlogv"]

# prepend b to show current branch only, non-elided
bl          = ["log", "-Tlog1", "-r::@", "-n25"]
bll         = ["log", "-Tlog1", "-r::@"]

blv         = ["log", "-Tlogv", "-r::@", "-n25"]
bllv        = ["log", "-Tlogv", "-r::@"]

# "log" aliases: other custom change lists, using the default template (builtin_log_compact)
#log                                                          # default log view: trunk and unmerged/unpushed branches, as two lines
logconflicts = ["log", "-r", "conflicts()"]                   # conflicting commits
lognew       = ["log", "-r", "(master..@):: | (master..@)-"]  # commits since master in current branch
logpush      = ["log", "-r", "trunk()::@"]                    # unpushed to origin in current branch
logpull      = ["log", "-r", "@..trunk()"]                    # unpulled from origin in current branch
logpullall   = ["log", "-r", "@-..remote_bookmarks()"]        # unpulled from all remotes in current branch

# op log
o          = ["op", "log"]                                      # all operations
oo         = ["op", "log", "-T", "builtin_op_log_comfortable"]  # all operations, with more whitespace

[revset-aliases]
'closest_bookmark(to)' = 'heads(::to & bookmarks())'
'closest_pushable(to)' = 'heads(::to & mutable() & ~description(exact:"") & (~empty() | merges()))'

[template-aliases]
# (From https://github.com/jj-vcs/jj/discussions/5812#discussioncomment-13095720)
# Additional templates and helpers.
# log templates. Most of these use my smlog() layout.
# Author's name, committer's timestamp and time zone, full descriptions.
logv = 'smlog(original_time(committer.timestamp()), description, bookmarks, tags)'
# Like logv but just one line of description.
log1 = 'smlog(local_time(committer.timestamp()), description.first_line(), bookmarks, tags)'

# helpers:
'local_time(timestamp)'       = 'timestamp.local().format("%Y-%m-%d %H:%M:%S")'
'localised_time(timestamp)'   = 'timestamp.local().format("%Y-%m-%d %H:%M:%S %z")'
'original_time(timestamp)'    = 'timestamp.format("%Y-%m-%d %H:%M:%S %z")'

# Generate a log template with a more aligned layout for readability:
# both hashes and other fixed width fields on the left,
# bookmarks and tags displayed optionally (used by jjbookmarks, jjtags),
# bookmarks enclosed in brackets to distinguish them from tags,
# description starting on the same line.
'smlog(timestr, description, bookmarks, tags)' = '''
if(root,
  format_root_commit(self),
  label(if(current_working_copy, "working_copy"),
    concat(
      separate(" ",
        format_short_change_id_with_hidden_and_divergent_info(self),
        format_short_commit_id(commit_id),
        timestr,
        if(author.email(), author.email().local(), email_placeholder),
        if(bookmarks,surround("[","]",bookmarks),""),
        tags,
        working_copies,
        if(git_head, label("git_head", "git_head()")),
        if(conflict, label("conflict", "conflict")),
        if(empty, label("empty", "(empty)")),
        if(description,
          description,
          label(if(empty, "empty"), description_placeholder),
        ),
      ) ++ "\n",
    ),
  )
)
'''
